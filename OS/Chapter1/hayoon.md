

# 📚 1.3 Computer-System Architecture 요약

## 1.3.1 Single-Processor Systems

- 과거 대부분의 시스템은 **단일 프로세서 시스템**
- **단일 CPU + 단일 코어**로 일반적인 명령어 세트 실행
- **특수 목적 프로세서** 존재 (예: 디스크, 키보드, 그래픽 컨트롤러)
  - 제한된 명령어 집합만 실행
  - 운영체제와 협력하거나 독립적으로 동작
- 특수 목적 프로세서가 있어도 **일반 목적 CPU가 1개면 단일 프로세서 시스템**


## 1.3.2 Multiprocessor Systems (다중 프로세서 시스템)

### ✅ 정의
- 여러 개의 프로세서가 하나의 시스템에 존재
- **CPU가 2개 이상**, 각자 싱글 코어 또는 멀티코어
- **성능 향상 (Throughput 증가)** 목적

### ✅ 구조 및 특징
- **공유 버스, 메모리, 장치 사용**
- **SMP (Symmetric Multiprocessing)**
  - 모든 CPU가 **동등하게** 모든 작업 수행
  - 각 CPU는 **개별 레지스터와 캐시** 보유, 메모리는 공유
  - 병렬 작업 가능, 자원 동적 공유
- **멀티코어 시스템** 포함
  - 하나의 칩에 여러 코어
  - **온칩 통신**으로 **더 빠르고 에너지 효율적**
- **캐시 구조**
  - 코어별 **L1 캐시** (빠름, 작음)
  - 코어 간 **공유 L2 캐시**

### ✅ 한계
- CPU 수가 많아지면 **버스 경쟁(bottleneck)** 발생
- 확장성 제한

## 1.3.3. Clustered Systems (클러스터 시스템)

### ✅ 정의
- **둘 이상의 독립 시스템(노드)**을 **네트워크로 연결**
- 각 노드는 보통 **멀티코어 시스템**
- **공유 스토리지** 및 **고속 인터커넥트 (예: LAN, InfiniBand)**로 연결

### ✅ 목적
- **고가용성 (High Availability)**
- **고성능 컴퓨팅 (HPC)**

### ✅ 고가용성 구조
- **Failover 지원** =>  컴퓨터 서버, 시스템, 네트워크 등에서 이상이 생겼을 때 예비 시스템으로 자동전환되는 기능
- **비대칭(Asymmetric)**: 한 노드 대기(Hot-standby), 다른 노드 작업
- **대칭(Symmetric)**: 모든 노드가 작업 + 감시

### ✅ 병렬 처리 (Parallelization)
- 작업을 여러 부분으로 나눠서 **동시에 실행**
- **클러스터 전용 소프트웨어 필요**

### ✅ 고급 형태
- **병렬 클러스터(Parallel Cluster)**: 여러 호스트가 동일 데이터 접근
- **DLM (Distributed Lock Manager)** 필요
- **WAN 클러스터**: 광역 네트워크 연결
- **SAN (Storage-Area Network)** 통한 스토리지 풀 공유


# 2.3.3 시스템 콜의 종류

시스템 콜은 총 6가지의 대분류로 나눌 수 있다. **프로세스 제어 (process control), 파일 관리 (file management), 장치 관리 (device management), 정보 유지 (information maintenance), 통신 (communications), 보호 (protection)** 이다.

## 2.3.3.1 프로세스 제어(process control)

◦ create process, terminate process
◦ load, execute
◦ get process attributes, set process attributes
◦ wait event, signal event
◦ allocate and free memory

실행중인 프로그램은 정상, 혹은 비정상적으로든 실행을 중단할 수 있어야한다. 만약 실행 중인 프로그램이 비정상 종료를 요청하거나 실행 도중 error trap을 일으키게 된다면, **메모리 덤프(memory dump)** 가 기록 되고 오류 메시지가 생기게 된다.
이 메모리 덤프는 특수 로그 파일에 저장되고, 우리가 아는 **디버거(debugger)** 가 이 오류 및 버그의 원인을 찾고 수정하는데 사용되게 된다.

또한, 정상/비정상 모든 상황에서 운영체제는 제어 권한을 **명령 인터프리터(command interpreter)** 에 넘겨야한다. 명령 프리터가 명령어를 읽는 방법은 다양한데

- 대화형 시스템에서는 명령 인터프리터가 다음 명령을 계속 수행하고, 사용자가 적절한 명령으로 오류에 대응할 거라고 가정한다.
- GUI 시스템에서는 팝업 창이 사용자에게 오류를 알고, 다음 행동을 물어본다.
- 특정 시스템에서는 특별 복구 작업을 허용한다.

만약 새 프로그램이 끝난 후, 기존 프로그램으로 컨트롤을 돌려줘야한다면 운영체제는 기존 프로그램의 **memory image** 를 보관하고 있어야한다.
따라서 한 프로그램이 다른 프로그램을 호출할 수 있는 매커니즘이 만들어지게 된다.

만약 두 프로그램이 동시에 실행되면, 이는 멀티프로그래밍을 위한 새 프로세스를 생성하게 되는 것이다. 새로운 프로세스를 생성하게 된다면, 당연히 해당 프로세스의 실행을 제어할 수 있어야한다.
프로세스의 속성인 우선순위, 허용 실행 시간등을 확인/재설정 할 수 있어야한다. 

새로운 프로세스를 만들어지면, 그 프로세스가 실행을 마칠때 까지 기다릴 필요가 있다. 또한 둘 이상의 프로세스가 데이터를 공유하는 일이 자주 발생한느데
이때 공유 데이터의 **무결성**을 보장하기 위해서 프로세스가 공유 데이터를 **lock**할 수 있는 기능을 제공한다. lock이 걸린 데이터는 다른 어떤 프로세스도 접근이 불가능하다.

## 2.3.3.2 파일 관리(File management)

◦ create file, delete file
◦ open, close
◦ read, write, reposition
◦ get file attributes, set file attributes

파일 시스템은 후에 더 다룬다. 파일에 대해서 CRUD가 가능해야하고, 이 파일들에 대한 속성을 설정할 수 있어야한다. 추가로, 다른 프로그램이 이 프로그램을 호출할 수 있다면, API처럼 작동할 수 있다고 이해하면 된다.


## 2.3.3.3 Device Management

프로세스가 실행되기 위해서는 여러 **자원(resources)** 이 필요할 수 있다.
예를 들어, 주기억장치(main memory), 디스크 드라이브(disk drives), 파일 접근(file access) 등이 있다.

만약 필요한 자원이 사용 가능하다면, 운영체제는 이를 할당(grant) 하고
제어(control) 를 다시 사용자 프로세스에 넘길 수 있다.
그러나 자원이 충분하지 않다면, 프로세스는 자원이 준비될 때까지 대기(wait) 해야 한다.

운영체제가 제어하는 다양한 자원은 모두 **장치(devices)** 로 볼 수 있다.
이 장치들 중 일부는 **물리적 장치(physical devices)** (예: 디스크 드라이브)이며,
다른 일부는 추상적 또는 **가상 장치(abstract or virtual devices)** (예: 파일)로 간주될 수 있다.

이렇게 운영체제에서 요청/할당 된 후에는, 파일처럼 read,write 등의 작업을 수행할 수 있게 된다.

## 2.3.3.4 정보 유지 (Information Maintenance)
운영체제와 사용자 프로그램 간에 정보를 주고받기 위한 시스템 콜들이 존재한다.
예를 들어, 현재 시간이나 날짜를 반환하는 time(), date() 시스템 콜, 운영체제 버전, 사용 가능한 메모리와 디스크 공간을 반환하는 시스템 콜 등이 있다.

또한, 디버깅을 위한 시스템 콜도 제공된다.
예를 들어, 메모리 상태를 덤프하는 dump() 시스템 콜이 있으며, strace와 같은 도구를 통해 프로그램이 호출하는 시스템 콜을 추적할 수 있다.

운영체제는 모든 프로세스 정보를 유지하므로, 프로세스의 속성을 조회하거나 설정하는 get process attributes(), set process attributes() 시스템 콜이 필요하다.

그리고 프로그램이 어느 부분에서 얼마나 실행되었는지를 기록하는 시간 프로파일(time profile) 기능도 지원된다.
이 기능은 성능 분석이나 최적화에 활용될 수 있다.

## 2.3.3.5 통신 (Communication)
운영체제는 프로세스 간 통신(IPC, Interprocess Communication) 을 지원하며, **메시지 전달(message-passing)** 모델과 **공유 메모리(shared-memory)** 모델이 있다.

메시지 전달 모델은 프로세스들이 서로 메시지를 주고받으며 데이터를 교환하는 방식이다.
이 모델에서는 연결을 생성하고(open connection), 메시지를 주고받으며(read/write message), 연결을 종료(close connection) 하는 시스템 콜들이 사용된다.
서버 프로세스는 accept connection() 시스템 콜을 통해 연결 요청을 수락하고, 클라이언트 프로세스와 통신한다.

공유 메모리 모델은 여러 프로세스가 동일한 메모리 공간을 공유하여 데이터를 교환하는 방식이다.
이 모델에서는 shared memory create(), shared memory attach() 시스템 콜을 통해 메모리를 공유한다.
단, 데이터의 동기화 문제는 프로세스들이 직접 해결해야 한다.

**메시지 전달은 소량의 데이터를 안전하게 주고받기에 적합**하며, 구현이 간단하다.
반면, **공유 메모리는 대량의 데이터를 빠르게 전송할 때 적합하지만, 동기화와 보호에 대한 추가적인 고려**가 필요하다.

## 2.3.3.6 보호 (Protection)
보호(Protection) 는 시스템 자원에 대한 접근을 제어하기 위한 기능이다.
과거에는 다중 사용자 환경에서만 중요하게 여겨졌으나,
오늘날에는 네트워크와 인터넷이 연결된 모든 시스템에서 보호가 필수적이다.

운영체제는 자원에 대한 접근 권한을 설정하거나 조회하는 set permission(), get permission() 시스템 콜을 제공한다.
또한, 특정 사용자에게 자원 접근을 허용하거나(allow user()), 거부하는(deny user()) 시스템 콜도 포함된다.

이러한 보호 기능을 통해 사용자 간 자원 충돌을 방지하고, 외부 공격으로부터 시스템을 보호할 수 있다.
