

# 📚 1.3 Computer-System Architecture 요약

## 1.3.1 Single-Processor Systems

- 과거 대부분의 시스템은 **단일 프로세서 시스템**
- **단일 CPU + 단일 코어**로 일반적인 명령어 세트 실행
- **특수 목적 프로세서** 존재 (예: 디스크, 키보드, 그래픽 컨트롤러)
  - 제한된 명령어 집합만 실행
  - 운영체제와 협력하거나 독립적으로 동작
- 특수 목적 프로세서가 있어도 **일반 목적 CPU가 1개면 단일 프로세서 시스템**


## 1.3.2 Multiprocessor Systems (다중 프로세서 시스템)

### ✅ 정의
- 여러 개의 프로세서가 하나의 시스템에 존재
- **CPU가 2개 이상**, 각자 싱글 코어 또는 멀티코어
- **성능 향상 (Throughput 증가)** 목적

### ✅ 구조 및 특징
- **공유 버스, 메모리, 장치 사용**
- **SMP (Symmetric Multiprocessing)**
  - 모든 CPU가 **동등하게** 모든 작업 수행
  - 각 CPU는 **개별 레지스터와 캐시** 보유, 메모리는 공유
  - 병렬 작업 가능, 자원 동적 공유
- **멀티코어 시스템** 포함
  - 하나의 칩에 여러 코어
  - **온칩 통신**으로 **더 빠르고 에너지 효율적**
- **캐시 구조**
  - 코어별 **L1 캐시** (빠름, 작음)
  - 코어 간 **공유 L2 캐시**

### ✅ 한계
- CPU 수가 많아지면 **버스 경쟁(bottleneck)** 발생
- 확장성 제한

## 1.3.3. Clustered Systems (클러스터 시스템)

### ✅ 정의
- **둘 이상의 독립 시스템(노드)**을 **네트워크로 연결**
- 각 노드는 보통 **멀티코어 시스템**
- **공유 스토리지** 및 **고속 인터커넥트 (예: LAN, InfiniBand)**로 연결

### ✅ 목적
- **고가용성 (High Availability)**
- **고성능 컴퓨팅 (HPC)**

### ✅ 고가용성 구조
- **Failover 지원** =>  컴퓨터 서버, 시스템, 네트워크 등에서 이상이 생겼을 때 예비 시스템으로 자동전환되는 기능
- **비대칭(Asymmetric)**: 한 노드 대기(Hot-standby), 다른 노드 작업
- **대칭(Symmetric)**: 모든 노드가 작업 + 감시

### ✅ 병렬 처리 (Parallelization)
- 작업을 여러 부분으로 나눠서 **동시에 실행**
- **클러스터 전용 소프트웨어 필요**

### ✅ 고급 형태
- **병렬 클러스터(Parallel Cluster)**: 여러 호스트가 동일 데이터 접근
- **DLM (Distributed Lock Manager)** 필요
- **WAN 클러스터**: 광역 네트워크 연결
- **SAN (Storage-Area Network)** 통한 스토리지 풀 공유


## 2.3.3 시스템 콜의 종류

시스템 콜은 총 6가지의 대분류로 나눌 수 있다. **프로세스 제어 (process control), 파일 관리 (file management), 장치 관리 (device management), 정보 유지 (information maintenance), 통신 (communications), 보호 (protection)** 이다.

### 2.3.3.1 프로세스 제어(process control)

- 프로세스 생성/종료, 프로그램 적재/실행
- 프로세스 속성 조회/설정, 이벤트 대기/알림
- 메모리 할당/해제까지 프로세스의 전반적인 생명주기와 관리에 관련된 모든 동작을 다룸.
- fork, exit, wait 등
- 
실행중인 프로그램은 정상, 혹은 비정상적으로든 실행을 중단할 수 있어야한다. 만약 실행 중인 프로그램이 비정상 종료를 요청하거나 실행 도중 error trap을 일으키게 된다면, **메모리 덤프(memory dump)** 가 기록 되고 오류 메시지가 생기게 된다.
이 메모리 덤프는 특수 로그 파일에 저장되고, 우리가 아는 **디버거(debugger)** 가 이 오류 및 버그의 원인을 찾고 수정하는데 사용되게 된다.

또한, 정상/비정상 모든 상황에서 운영체제는 제어 권한을 **명령 인터프리터(command interpreter)** 에 넘겨야한다. 명령 프리터가 명령어를 읽는 방법은 다양한데

- 대화형 시스템에서는 명령 인터프리터가 다음 명령을 계속 수행하고, 사용자가 적절한 명령으로 오류에 대응할 거라고 가정한다.
- GUI 시스템에서는 팝업 창이 사용자에게 오류를 알고, 다음 행동을 물어본다.
- 특정 시스템에서는 특별 복구 작업을 허용한다.

만약 새 프로그램이 끝난 후, 기존 프로그램으로 컨트롤을 돌려줘야한다면 운영체제는 기존 프로그램의 **memory image** 를 보관하고 있어야한다.
따라서 한 프로그램이 다른 프로그램을 호출할 수 있는 매커니즘이 만들어지게 된다.

만약 두 프로그램이 동시에 실행되면, 이는 멀티프로그래밍을 위한 새 프로세스를 생성하게 되는 것이다. 새로운 프로세스를 생성하게 된다면, 당연히 해당 프로세스의 실행을 제어할 수 있어야한다.
프로세스의 속성인 우선순위, 허용 실행 시간등을 확인/재설정 할 수 있어야한다. 

새로운 프로세스를 만들어지면, 그 프로세스가 실행을 마칠때 까지 기다릴 필요가 있다. 또한 둘 이상의 프로세스가 데이터를 공유하는 일이 자주 발생한느데
이때 공유 데이터의 **무결성**을 보장하기 위해서 프로세스가 공유 데이터를 **lock**할 수 있는 기능을 제공한다. lock이 걸린 데이터는 다른 어떤 프로세스도 접근이 불가능하다.

